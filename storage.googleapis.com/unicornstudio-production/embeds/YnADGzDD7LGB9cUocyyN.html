{"history":[{"visible":true,"aspectRatio":1,"layerType":"effect","type":"gradient","speed":0.25,"mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;const
vec3 uColors[1] = vec3[]( vec3(1.000000, 1.000000, 1.000000) );uniform float uTime;uniform sampler2D uMaskTexture; uniform float uAspectRatio; uniform vec2 uMousePos; uniform vec2 uResolution;vec2 rotate(vec2 coord, float angle) { float s = sin(angle);
float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }float rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453); }vec3 linear_from_srgb(vec3 rgb) { return pow(rgb, vec3(2.2)); }vec3 srgb_from_linear(vec3
lin) { return pow(lin, vec3(1.0/2.2)); }vec3 oklab_mix(vec3 lin1, vec3 lin2, float a) { const mat3 kCONEtoLMS = mat3( 0.4121656120, 0.2118591070, 0.0883097947, 0.5362752080, 0.6807189584, 0.2818474174, 0.0514575653, 0.1074065790, 0.6302613616); const
mat3 kLMStoCONE = mat3( 4.0767245293, -1.2681437731, -0.0041119885, -3.3072168827, 2.6093323231, -0.7034763098, 0.2307590544, -0.3411344290, 1.7068625689); vec3 lms1 = pow( kCONEtoLMS*lin1, vec3(1.0/3.0) ); vec3 lms2 = pow( kCONEtoLMS*lin2, vec3(1.0/3.0)
); vec3 lms = mix( lms1, lms2, a ); lms *= 1.0+0.025*a*(1.0-a); return kLMStoCONE*(lms*lms*lms); }vec3 getGradientColor(float position) { for (int i = 0; i
< 1; i++) { float colorPosition=f loat(i) / float(1); float nextColorPosition=f loat(i + 1) / float(1);
    if (position <=n extColorPosition) { float mixFactor=( position - colorPosition) / (nextColorPosition - colorPosition); vec3 linStart=l inear_from_srgb(uColors[i]); vec3 linEnd=l inear_from_srgb(uColors[i + 1]); vec3 mixedLin=o klab_mix(linStart, linEnd,
    mixFactor); return srgb_from_linear(mixedLin); } } return srgb_from_linear(uColors[1-1]); }vec3 Tonemap_ACES(vec3 x) { const float a=2 .51; const float b=0 .03; const float c=2 .43; const float d=0 .59; const float e=0 .14; return (x * (a * x + b)) /
    (x * (c * x + d) + e); }out vec4 fragColor;void main() { vec2 uv=v TextureCoord; vec2 pos=v ec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); uv -=p os; uv /=( 0.50*2.); uv=r otate(uv, (0.00 - 0.5) * 2. * 3.14159265);vec4 color=v ec4(0,0,0,1);float
    position; if(1==1 ) { color.rgb=u Colors[0]; } else if (0==0 ) { position=( uv.x+0.5);} else if (0==1 ) { position=l ength(uv); } else if (0==2 ) { float angle=a tan(uv.y, uv.x); float normalizedAngle=a ngle / (2.0 * 3.14159265359) + 0.5; float doubledAngle=2
    .0 * normalizedAngle; doubledAngle=d oubledAngle> 1. ? 2.0 - doubledAngle : doubledAngle; position = clamp(doubledAngle, 0.0, 1.0); } else if (0 == 3) { } if(1 > 1) { position -= (uTime*0.01 + 0.00); float cycle = floor(position); bool reverse = int(cycle) % 2 == 0; float animatedPos = reverse ? fract(-position)
    : fract(position); animatedPos = reverse ? animatedPos - 1./float(1) : animatedPos - 1./float(1);color.rgb = getGradientColor(animatedPos); float dither = rand(gl_FragCoord.xy) * 0.005; color.rgb += dither; }fragColor = color; }"],"compiledVertexShaders":["#version
    300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix
    * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{}},{"local":{"id":"781083b9-4c36-40a5-a82c-48864e3eedcf","canvas":{},"ctx":{}},"visible":true,"locked":false,"aspectRatio":1.6,"isElement":true,"opacity":1,"displace":0.4,"trackMouse":0,"mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":1,"dispersion":1,"axisTilt":0.49,"layerType":"shape","borderRadius":0,"coords":[[0,0],[699,0],[699,442],[0,442]],"effects":[],"fill":["#FFFFFF"],"gradientAngle":0,"gradientType":"linear","mask":0,"rotation":0,"translateX":-3,"translateY":-4,"type":"rectangle","numSides":3,"compiledFragmentShaders":["#version
    300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform vec2 uResolution; uniform vec2 uMousePos; uniform sampler2D uBgTexture; uniform sampler2D uMaskTexture; uniform sampler2D uTexture; uniform int uSampleBg;vec3
    blend (int blendMode, vec3 src, vec3 dst) { return src; }const float STEPS = 24.0; const float PI = 3.1415926;vec3 refrakt(vec3 eyeVector, vec3 normal, float iorRatio) { float dotProduct = dot(eyeVector, normal); float k = 1.0 - iorRatio * iorRatio
    * (1.0 - dotProduct * dotProduct); if (k
    < 0.0) { return reflect(eyeVector, normal); } else { return iorRatio * eyeVector - (iorRatio * dotProduct + sqrt(k)) * normal; } }vec4 displacement (vec2 st, vec4 bg, vec4 color) { if(1.00==1 .0) { vec2 refraction=r
        efrakt(vec3(vTextureCoord, 0.5), color.rgb, 0.40-0.5).xy; vec2 displaced=v TextureCoord + mix(vec2(0), refraction * 0.1, 0.40); vec4 bgDisp=t exture(uBgTexture, displaced); bgDisp.rgb=b gDisp.rgb; return bgDisp * color.a; } else { vec2 normal=v ec2(bg.r
        * 2.0 - 1.0, bg.g * 2.0 - 1.0) * 0.1; if(0.00==1 .) { return texture(uMaskTexture, st + normal * 0.40) * texture(uTexture, st + normal * 0.40).a; } else { return texture(uTexture, st + normal * 0.40); } } }vec2 perspectiveUV(vec2 uv) { float aspectRatio=u
        Resolution.x/uResolution.y; vec2 centeredUV=u v - 0.5; centeredUV.x *=a spectRatio; float strength=1 .0 + (vVertexPosition.z * 0.49); vec2 perspectiveUV=c enteredUV / strength; perspectiveUV.x /=a spectRatio; perspectiveUV +=0 .5; return perspectiveUV;
        }out vec4 fragColor;void main() { vec2 uv=v TextureCoord; vec2 pos=m ix(vec2(0), (uMousePos - 0.5), 0.00); uv=p erspectiveUV(uv) - pos; vec4 maskColor=t exture(uMaskTexture, vTextureCoord); vec4 background=u SampleBg==1 ? texture(uBgTexture, vTextureCoord)
        : vec4(0); vec4 color=t exture(uTexture, uv);if (0.00==1 .) { color=m askColor * color.a; }if (0.40> 0.) { if(0.00 == 1.) { color = displacement(uv, background, maskColor); } else { color = displacement(uv, background, color); } }if (0 > 0) { color.rgb = blend(0, color.rgb, background.rgb); }color = mix(background, color/(color.a + 0.00000001), color.a
        * 1.00); fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out
        vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX),
        0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition,
        1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"]},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"mouse","mouseMomentum":0.47,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version
        300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform sampler2D uPingPongTexture; uniform vec2 uResolution;uniform float uTime;const float PI = 3.1415926;out vec4 fragColor;vec3 rgb2hsv(vec3
        c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z
        + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }vec3 chromatic_abberation(vec3 color, vec2 uv, vec2 offset) { vec4 left = texture(uTexture, uv - offset); vec4 right = texture(uTexture, uv + offset);color.r = left.r; color.b = right.b;return
        color; }vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) { return a + b*cos( 6.28318*(c*t+d) ); }const float ITERATIONS = 25.;vec4 revealTrail(vec2 uv, vec2 mouseDir, float strength) { vec4 color = vec4(0); float zMix = strength;
        vec2 distorted = mouseDir * 0.4 * 0.50; color = texture(uTexture, uv - distorted); color.rgb = chromatic_abberation(color.rgb, uv - distorted, distorted * 1.00*0.12); color = mix(vec4(vec3(0, 0, 0), 0.00), color, zMix); return color; }vec4 getTrailColor(vec2
        uv, vec2 mouseDir, float strength) { vec4 color = vec4(0); float aspectRatio = uResolution.x/uResolution.y;return revealTrail(uv, mouseDir, strength); }void main() { vec2 uv = vTextureCoord; vec3 mouseRgb = texture(uPingPongTexture, uv).rgb; vec3
        mouseTrail = rgb2hsv(mouseRgb);float angle = mouseTrail.x; float strength = mouseTrail.z * (0.69 * 2.); vec2 direction = vec2(cos(angle * 2. * PI), sin(angle * 2. * PI)); vec2 mouseDir = direction * strength; vec4 color = getTrailColor(uv, mouseDir,
        strength);fragColor = color; }","#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform sampler2D uPingPongTexture; uniform vec2 uMousePos; uniform vec2 uPreviousMousePos;
        uniform vec2 uResolution; uniform float uTime;const float PI = 3.1415926;out vec4 fragColor;vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw,
        c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }vec3 hsv2rgb(vec3 c) { vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p =
        abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec2 liquify(vec2 st, float angle) { float aspectRatio = uResolution.x / uResolution.y;
        st.x *= aspectRatio; st = st * rot(angle * 2. * PI); float amplitude = 0.003; for(float i = 1.0; i
        <=5 .0; i++) { st=s t * rot(i/5. * PI * 2.); st +=v ec2( amplitude * cos(i * 5.0 * st.y + uTime * 0.02), amplitude * sin(i * 5.0 * st.x + uTime
            * 0.02) ); } st=s t * rot(angle * -1. * 2. * PI); st.x /=a spectRatio; return st; }const float TWOPI=6 .2831852; const float edgeSoftness=0 .75; void main() { float aspectRatio=u Resolution.x / uResolution.y; vec2 uv=v TextureCoord; vec2 correctedUv=u
            v * vec2(aspectRatio, 1.0); vec2 dir=u MousePos * vec2(aspectRatio, 1.0) - uPreviousMousePos * vec2(aspectRatio, 1.0); float dist=l ength(dir); dir=n ormalize(dir); float rad=0 .10 * 0.4 * mix(aspectRatio, 1.0, 0.5); float angle=a tan(dir.y, dir.x);
            angle +=a ngle < 0.0 ? TWOPI : 0.0; uv=m ix(uv, liquify(uv, smoothstep(0.0, 1.0, angle)), 0.56); float t=c lamp(dot(correctedUv - uPreviousMousePos * vec2(aspectRatio, 1.0), dir) / dist, 0.0, 1.0); vec2 closestPoint=m ix(uPreviousMousePos, uMousePos,
            t) * vec2(aspectRatio, 1.0); float distanceToLine=d istance(correctedUv, closestPoint); float s=s moothstep(rad, rad * 0.30, distanceToLine) * smoothstep(0.0, dist, length(closestPoint - uPreviousMousePos * vec2(aspectRatio, 1.0)));vec3 color=v
            ec3(0.8333, 1.0, 1.0); color.x=a ngle / TWOPI; vec3 mouseColor=h sv2rgb(color);vec3 lastFrameColor=t exture(uPingPongTexture, mix(uv, uv / 1.03 + 0.015, 0.09)).rgb;vec3 draw=m ix(lastFrameColor, mouseColor, dist * s);fragColor=v ec4(draw * pow(0.73,
            0.1), 1.0); } "],"compiledVertexShaders ":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;uniform sampler2D uPingPongTexture;out vec3 vVertexPosition; out
            vec2 vTextureCoord;vec3 rgb2hsv(vec3 c) { vec4 K=v ec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p=m ix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q=m ix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d=q .x - min(q.w,
            q.y); float e=1 .0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }const float PI=3 .1415926;void main() {vec3 vertexPosition=a VertexPosition;gl_Position=u PMatrix * uMVMatrix * vec4(vertexPosition, 1.0); vTextureCoord=a
            TextureCoord; } ","#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec3 vVertexPosition; out vec2 vTextureCoord;void main() {vec3 vertexPosition=a VertexPosition;gl_Position=u
            PMatrix * uMVMatrix * vec4(vertexPosition, 1.0); vTextureCoord=a TextureCoord; vVertexPosition=v ertexPosition; } "],"data ":{}},{"visible ":true,"aspectRatio ":1,"layerType ":"effect ","type ":"mouse ","mouseMomentum ":0,"texture ":false,"animating
            ":true,"isMask ":0,"compiledFragmentShaders ":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform sampler2D uPingPongTexture; uniform vec2 uResolution;uniform float uTime;const
            float PI=3 .1415926;out vec4 fragColor;vec3 rgb2hsv(vec3 c) { vec4 K=v ec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p=m ix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q=m ix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float
            d=q .x - min(q.w, q.y); float e=1 .0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }vec3 chromatic_abberation(vec3 color, vec2 uv, vec2 offset) { vec4 left=t exture(uTexture, uv - offset); vec4 right=t exture(uTexture,
            uv + offset);color.r=l eft.r; color.b=r ight.b;return color; }float Gaussian(float x, float sigma) { return exp(-x * x / (2.0 * sigma * sigma)) / (sqrt(2.0 * 3.14159265) * sigma); }vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3
            d ) { return a + b*cos( 6.28318*(c*t+d) ); }const float ITERATIONS=2 5.;vec4 blurTrail (vec2 uv, vec2 mouseDir) { vec2 distorted=m ouseDir * 0.4; float total_weight=0 .0; vec4 color=v ec4(0);for(float i=- ITERATIONS; i <=I TERATIONS; i++) { float
            scale=0 .0001 + 0.50 * 0.5; float weight=G aussian(i/ITERATIONS, scale); vec2 offset=d istorted * (1.5+scale) * mix(1., i / ITERATIONS, scale); vec4 samp=t exture(uTexture, uv - offset); samp.rgb=c hromatic_abberation(samp.rgb, uv - offset, offset*1.00*0.12);
            color +=w eight * samp; total_weight +=w eight; } return color / total_weight; }vec4 getTrailColor(vec2 uv, vec2 mouseDir, float strength) { vec4 color=v ec4(0); float aspectRatio=u Resolution.x/uResolution.y;return blurTrail(uv, mouseDir); }void
            main() { vec2 uv=v TextureCoord; vec3 mouseRgb=t exture(uPingPongTexture, uv).rgb; vec3 mouseTrail=r gb2hsv(mouseRgb);float angle=m ouseTrail.x; float strength=m ouseTrail.z * (0.58 * 2.); vec2 direction=v ec2(cos(angle * 2. * PI), sin(angle *
            2. * PI)); vec2 mouseDir=d irection * strength; vec4 color=g etTrailColor(uv, mouseDir, strength);fragColor=c olor; } ","#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform
            sampler2D uPingPongTexture; uniform vec2 uMousePos; uniform vec2 uPreviousMousePos; uniform vec2 uResolution; uniform float uTime;const float PI=3 .1415926;out vec4 fragColor;vec3 rgb2hsv(vec3 c) { vec4 K=v ec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
            vec4 p=m ix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q=m ix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d=q .x - min(q.w, q.y); float e=1 .0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e),
            q.x); }vec3 hsv2rgb(vec3 c) { vec4 K=v ec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p=a bs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a));
            }vec2 liquify(vec2 st, float angle) { float aspectRatio=u Resolution.x / uResolution.y; st.x *=a spectRatio; st=s t * rot(angle * 2. * PI); float amplitude=0 .003; for(float i=1 .0; i <=5 .0; i++) { st=s t * rot(i/5. * PI * 2.); st +=v ec2( amplitude
            * cos(i * 5.0 * st.y + uTime * 0.02), amplitude * sin(i * 5.0 * st.x + uTime * 0.02) ); } st=s t * rot(angle * -1. * 2. * PI); st.x /=a spectRatio; return st; }const float TWOPI=6 .2831852; const float edgeSoftness=0 .75; void main() { float aspectRatio=u
            Resolution.x / uResolution.y; vec2 uv=v TextureCoord; vec2 correctedUv=u v * vec2(aspectRatio, 1.0); vec2 dir=u MousePos * vec2(aspectRatio, 1.0) - uPreviousMousePos * vec2(aspectRatio, 1.0); float dist=l ength(dir); dir=n ormalize(dir); float
            rad=0 .10 * 0.4 * mix(aspectRatio, 1.0, 0.5); float angle=a tan(dir.y, dir.x); angle +=a ngle < 0.0 ? TWOPI : 0.0; uv=m ix(uv, liquify(uv, smoothstep(0.0, 1.0, angle)), 0.00); float t=c lamp(dot(correctedUv - uPreviousMousePos * vec2(aspectRatio,
            1.0), dir) / dist, 0.0, 1.0); vec2 closestPoint=m ix(uPreviousMousePos, uMousePos, t) * vec2(aspectRatio, 1.0); float distanceToLine=d istance(correctedUv, closestPoint); float s=s moothstep(rad, rad * 0.80, distanceToLine) * smoothstep(0.0, dist,
            length(closestPoint - uPreviousMousePos * vec2(aspectRatio, 1.0)));vec3 color=v ec3(0.8333, 1.0, 1.0); color.x=a ngle / TWOPI; vec3 mouseColor=h sv2rgb(color);vec3 lastFrameColor=t exture(uPingPongTexture, mix(uv, uv / 1.03 + 0.015, 0.00)).rgb;vec3
            draw=m ix(lastFrameColor, mouseColor, dist * s);fragColor=v ec4(draw * pow(0.50, 0.1), 1.0); } "],"compiledVertexShaders ":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform
            mat4 uPMatrix;uniform sampler2D uPingPongTexture;out vec3 vVertexPosition; out vec2 vTextureCoord;vec3 rgb2hsv(vec3 c) { vec4 K=v ec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p=m ix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q=m
            ix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d=q .x - min(q.w, q.y); float e=1 .0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }const float PI=3 .1415926;void main() {vec3 vertexPosition=a VertexPosition;gl_Position=u
            PMatrix * uMVMatrix * vec4(vertexPosition, 1.0); vTextureCoord=a TextureCoord; } ","#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec3 vVertexPosition;
            out vec2 vTextureCoord;void main() {vec3 vertexPosition=a VertexPosition;gl_Position=u PMatrix * uMVMatrix * vec4(vertexPosition, 1.0); vTextureCoord=a TextureCoord; vVertexPosition=v ertexPosition; } "],"data ":{}},{"visible ":true,"aspectRatio
            ":1,"layerType ":"effect ","type ":"diffuse ","speed ":0.25,"mouseMomentum ":0,"texture ":false,"animating ":false,"isMask ":0,"compiledFragmentShaders ":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform
            float uTime; uniform float xy;uniform sampler2D uMaskTexture; uniform float uAspectRatio; uniform vec2 uMousePos; uniform vec2 uResolution;float ease (int easingFunc, float t) { return t; }const float MAX_ITERATIONS=2 4.; const float PI=3 .14159265;
            const float TWOPI=6 .2831853;float random(vec2 seed) { seed.x *=u Resolution.x/uResolution.y; return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }out vec4 fragColor;void main() { vec2 uv=v TextureCoord; vec2 pos=v ec2(0.5, 0.5)
            + mix(vec2(0), (uMousePos-0.5), 0.00); float aspectRatio=u Resolution.x/uResolution.y; float delta=f ract(floor(uTime)/20.); float angle, rotation, amp; float inner=d istance(uv * vec2(aspectRatio, 1), pos * vec2(aspectRatio, 1)); float outer=m
            ax(0., 1.-distance(uv * vec2(aspectRatio, 1), pos * vec2(aspectRatio, 1)));if(0.08==0 .) { fragColor=t exture(uTexture, uv); return; }float amount=0 .08 * ease(0, mix(inner, outer, 0.50)) * 2.;vec2 mPos=v ec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5),
            0.00); pos=v ec2(0.5, 0.5); float dist=e ase(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.00)));if(dist < distance(uv, mPos)) { vec4 color=t exture(uTexture, uv); if(0==1 ) { vec2 pos=m ix(vec2(0),
            (uMousePos - 0.5), 0.00); vec4 maskColor=t exture(uMaskTexture, vTextureCoord - pos); fragColor=c olor * (maskColor.a * maskColor.a); } else { fragColor=c olor; }}amount *=d ist;vec4 result=v ec4(0); float threshold=m ax(1. - 0.50, 2./MAX_ITERATIONS);for(float
            i=1 .; i <=M AX_ITERATIONS; i++) { float th=i /MAX_ITERATIONS; if(th> threshold) break;vec2 ranPoint = vec2( random(uv + th) * 2. - 1., random(uv + th * 2.) * 2. - 1. ) * mix(1., random(uv + th * 3.), 0.8); vec2 offset = ranPoint * vec2(0.50, 1.-0.50) * amount * 0.4; offset.x /= aspectRatio; result += texture(uTexture,
            uv + offset); }result /= floor(MAX_ITERATIONS * threshold);vec4 col =result; if(0 == 1) { vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - pos); fragColor = col * (maskColor.a * maskColor.a);
            } else { fragColor = col; }}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord;
            out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"sine","speed":0.04,"mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version
            300 es\nprecision mediump float;in vec2 vTextureCoord; in vec3 vVertexPosition; uniform sampler2D uTexture; uniform sampler2D uMaskTexture; uniform float uAspectRatio; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc,
            float t) { return t; } out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 wave = vVertexPosition.xy * 0.5 + 0.5; float aspectRatio = uResolution.x/uResolution.y;vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00);
            vec2 pos = vec2(0.5, 0.5); float dist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.00))); uv = mix(uv, wave, dist);vec4 color = texture(uTexture, uv); if(0 == 1) { vec2 pos = mix(vec2(0),
            (uMousePos - 0.5), 0.00); vec4 maskColor = texture(uMaskTexture, vTextureCoord - pos); fragColor = color * (maskColor.a * maskColor.a); } else { fragColor = color; }}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float; in
            vec3 aVertexPosition; in vec2 aTextureCoord; uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec3 vVertexPosition; out vec2 vTextureCoord;uniform float uTime; uniform sampler2D uMaskTexture; uniform float uAspectRatio; uniform vec2 uMousePos;
            uniform vec2 uResolution; vec2 rotateUV(vec2 uv, float rotation) { float mid = 0.5; return vec2( cos(rotation) * (uv.x - mid) + sin(rotation) * (uv.y - mid) + mid, cos(rotation) * (uv.y - mid) - sin(rotation) * (uv.x - mid) + mid ); }const
            float PI = 3.141592;void main() { vec3 vertexPosition = aVertexPosition; vec2 waveCoord = vec2(vertexPosition.xy); float angle = (0.00 * 360.) * 3.1415926 / 180.; float thirdPI = PI * 0.3333; float time = uTime*0.25; float frequency = 20.0
            * 0.50; float dist = 1.-distance(vec2(0.5, 0.5), aTextureCoord); dist = max(0., dist); float amp = 0.38 * 0.2;float waveX = sin((waveCoord.y + vec2(0.5, 0.5).y) * frequency + (time * thirdPI)) * amp; float waveY = sin((waveCoord.x - vec2(0.5,
            0.5).x) * frequency + (time * thirdPI)) * amp; waveCoord.xy += vec2(mix(waveX, 0., 0.00), mix(0., waveY, 0.00));if(vertexPosition.x == 1.) { waveCoord.x = 1.; } if(vertexPosition.x == -1.) { waveCoord.x = -1.; } if(vertexPosition.y == 1.)
            { waveCoord.y = 1.; } if(vertexPosition.y == -1.) { waveCoord.y = -1.; }gl_Position = uPMatrix * uMVMatrix * vec4(vec3(aVertexPosition), 1.0);vTextureCoord = aTextureCoord; vertexPosition.xy = waveCoord; vVertexPosition = vertexPosition; }"],"data":{}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"godrays","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version
            300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform sampler2D uBlueNoise; uniform float uDecay; uniform float uTime;uniform sampler2D uMaskTexture;
            uniform float uAspectRatio; uniform vec2 uMousePos; uniform vec2 uResolution;const float MAX_ITERATIONS = 100.; const float PI2 = 6.28318530718; const float TAU = 6.28318530718; const float EPSILON = 0.0001;float getBlueNoiseOffset(vec2 coord)
            { ivec2 texSize = textureSize(uBlueNoise, 0); vec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(coord * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0); float blueNoiseSample = blueNoise.r; return
            mod((blueNoiseSample * PI2) + (uTime * (1.0 / PI2)), PI2); }vec3 godRays(vec2 st, float decay) { vec3 color = vec3(0); float offset = (0.25 + min(1., 0.84)) * 0.0078; vec2 direction = mix(vec2(1, 0), vec2(0, 1), 0.00); vec2 pos = vec2(0.5,
            0.5) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.00); float distToPos = length(pos - st); float weight = 1.0; float blueNoiseOffset = getBlueNoiseOffset(st) * 0.84;for (float i = 0.0; i
            <=M AX_ITERATIONS; i++) { float
                x=m in(0.999, i * offset); x +=b lueNoiseOffset * 0.004; x=m in(0.999, x); vec2 marchPos=s t * (1.0 - x) + vec2(x * 0.5) + (pos - 0.5) * x + vec2(cos(blueNoiseOffset), sin(blueNoiseOffset)) * 0.001; color +=t exture(uTexture, marchPos).rgb
                * weight; weight *=d ecay; } return color / MAX_ITERATIONS; }vec3 Tonemap_tanh(vec3 x) { x=c lamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }out vec4 fragColor;void main() { vec2 uv=v TextureCoord; vec4 color=v ec4(0,0,0,1);
                if(0 !=1 ) { color=t exture(uTexture, uv); float lum=d ot(color.rgb, vec3(0.299, 0.587, 0.114)); color=c olor * smoothstep(0.20 - 0.1, 0.20, lum); } else { float decay=0 .972; vec3 rays=g odRays(uv, decay); rays *=v ec3(1, 1, 1); color.rgb=T
                onemap_tanh(rays); vec4 bg=t exture(uBgTexture, uv); color.rgb=b g.rgb + (color.rgb * 0.50 * 5.); color.a=b g.a + color.r; } if(0==1 ) { vec2 pos=m ix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor=t exture(uMaskTexture, vTextureCoord -
                pos); fragColor=c olor * (maskColor.a * maskColor.a); } else { fragColor=c olor; }} ","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform
                sampler2D uBlueNoise; uniform float uDecay; uniform float uTime;uniform sampler2D uMaskTexture; uniform float uAspectRatio; uniform vec2 uMousePos; uniform vec2 uResolution;const float MAX_ITERATIONS=1 00.; const float PI2=6 .28318530718;
                const float TAU=6 .28318530718; const float EPSILON=0 .0001;float getBlueNoiseOffset(vec2 coord) { ivec2 texSize=t extureSize(uBlueNoise, 0); vec4 blueNoise=t exelFetch(uBlueNoise, ivec2(fract(coord * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y,
                1.0)) * vec2(texSize)) % texSize, 0); float blueNoiseSample=b lueNoise.r; return mod((blueNoiseSample * PI2) + (uTime * (1.0 / PI2)), PI2); }vec3 godRays(vec2 st, float decay) { vec3 color=v ec3(0); float offset=( 0.25 + min(1., 0.84)) * 0.0078;
                vec2 direction=m ix(vec2(1, 0), vec2(0, 1), 0.00); vec2 pos=v ec2(0.5, 0.5) - mix(vec2(0), (vec2(1. - uMousePos.x, 1. - uMousePos.y) - 0.5), 0.00); float distToPos=l ength(pos - st); float weight=1 .0; float blueNoiseOffset=g etBlueNoiseOffset(st)
                * 0.84;for (float i=0 .0; i <=M AX_ITERATIONS; i++) { float x=m in(0.999, i * offset); x +=b lueNoiseOffset * 0.004; x=m in(0.999, x); vec2 marchPos=s t * (1.0 - x) + vec2(x * 0.5) + (pos - 0.5) * x + vec2(cos(blueNoiseOffset), sin(blueNoiseOffset))
                * 0.001; color +=t exture(uTexture, marchPos).rgb * weight; weight *=d ecay; } return color / MAX_ITERATIONS; }vec3 Tonemap_tanh(vec3 x) { x=c lamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }out vec4 fragColor;void main()
                { vec2 uv=v TextureCoord; vec4 color=v ec4(0,0,0,1); if(1 !=1 ) { color=t exture(uTexture, uv); float lum=d ot(color.rgb, vec3(0.299, 0.587, 0.114)); color=c olor * smoothstep(0.20 - 0.1, 0.20, lum); } else { float decay=0 .972; vec3 rays=g
                odRays(uv, decay); rays *=v ec3(1, 1, 1); color.rgb=T onemap_tanh(rays); vec4 bg=t exture(uBgTexture, uv); color.rgb=b g.rgb + (color.rgb * 0.50 * 5.); color.a=b g.a + color.r; } if(0==1 ) { vec2 pos=m ix(vec2(0), (uMousePos - 0.5), 0.00);
                vec4 maskColor=t exture(uMaskTexture, vTextureCoord - pos); fragColor=c olor * (maskColor.a * maskColor.a); } else { fragColor=c olor; }} "],"compiledVertexShaders ":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2
                aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position=u PMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord=( uTextureMatrix
                * vec4(aTextureCoord, 0.0, 1.0)).xy; } "],"data ":{"passes ":[{"prop ":"final ","value ":1,"includeBg ":true}],"texture ":{"src ":"https://assets.unicorn.studio/media/blue_noise_med.png ","sampler ":"uBlueNoise "}}},{"visible ":true,"aspectRatio
                ":1,"layerType ":"effect ","type ":"blinds ","speed ":0.05,"mouseMomentum ":0,"texture ":false,"animating ":true,"isMask ":0,"compiledFragmentShaders ":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord;uniform sampler2D uTexture;
                uniform float uTime;uniform sampler2D uMaskTexture; uniform float uAspectRatio; uniform vec2 uMousePos; uniform vec2 uResolution;float ease (int easingFunc, float t) { return t; }const float STEPS=1 0.0;const float PI=3 .14159265359;mat2 rot(float
                a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec3 chromatic_abberation(vec2 st, vec2 aberrated) { vec4 red=v ec4(0); vec4 blue=v ec4(0); vec4 green=v ec4(0);float invSteps=1 .0 / STEPS; float invStepsHalf=i nvSteps * 0.5;for(float i=1
                .0; i <=S TEPS; i++) { vec2 offset=a berrated * (i * invSteps); red +=t exture(uTexture, st - offset) * invSteps; blue +=t exture(uTexture, st + offset) * invSteps; green +=t exture(uTexture, st - offset * 0.5) * invStepsHalf; green +=t exture(uTexture,
                st + offset * 0.5) * invStepsHalf; }return vec3(red.r, green.g, blue.b); }vec2 scaleAspect(vec2 st, float aspectRatio) { return st * vec2(aspectRatio, 1.0); }vec2 unscaleAspect(vec2 st, float aspectRatio) { return st * vec2(1.0/aspectRatio,
                1.0); }vec2 rotate(vec2 st, float angle) { float s=s in(angle); float c=c os(angle); mat2 rot=m at2(c, -s, s, c); return rot * st; }vec4 blinds(vec2 st, float mDist) { float aspectRatio=u Resolution.x/uResolution.y; vec2 pos=v ec2(0.5, 0.5)
                + mix(vec2(0), (uMousePos-0.5), 0.00) * floor(1.00); pos=s caleAspect(pos, aspectRatio); st=s caleAspect(st, aspectRatio); st=r otate(st - pos, -0.11 * 2.0 * PI) + pos;vec3 distort=v ec3(0); float divisions=2 . + 0.50 * 30.; float dist=0 .33
                * 4. + 1.; float segment=0 .;float amount=1 .00 * mDist;vec3 first=v ec3(1,0,0); vec3 second=v ec3(0,1,0); vec3 third=v ec3(0,0,1); if(0==0 ) { segment=f ract((st.y + 1. - pos.y - 1. + uTime*0.01) * divisions); distort=m ix(mix(first, second,
                segment*2.), mix(second, third, (segment - 0.5)/(1. - 0.5)), step(0.5, segment)); st.y -=p ow(distort.r, dist)/10. * amount; st.y +=p ow(distort.b, dist)/10. * amount; } else if(0==1 ) { segment=f ract((st.x + 1. - pos.x - 1. + uTime*0.01)
                * divisions); distort=m ix(mix(first, second, segment*2.), mix(second, third, (segment - 0.5)/(1. - 0.5)), step(0.5, segment)); st.x -=p ow(distort.r, dist)/10. * amount; st.x +=p ow(distort.b, dist)/10. * amount; } else if(0==2 ) { segment=f
                ract((st.x + 1. - pos.x - 1. + uTime*0.01) * divisions); distort=m ix(mix(first, second, segment*2.), mix(second, third, (segment - 0.5)/(1. - 0.5)), step(0.5, segment)); st.x -=p ow(distort.r, dist)/10. * amount; st.x +=p ow(distort.b, dist)/10.
                * amount;segment=f ract((st.y + 1. - pos.y - 1. + uTime*0.01) * divisions); distort=m ix(mix(first, second, segment*2.), mix(second, third, (segment - 0.5)/(1. - 0.5)), step(0.5, segment)); st.y -=p ow(distort.r, dist)/10. * amount; st.y +=p
                ow(distort.b, dist)/10. * amount; } else if(0==3 ) { vec2 diff=s t - pos; float angle=a tan(diff.y, diff.x); segment=f ract((angle + uTime*0.01 + PI) / (2. * PI) * divisions);distort=m ix(mix(first, second, segment*2.), mix(second, third,
                (segment - 0.5)/(1. - 0.5)), step(0.5, segment)); st -=p ow(distort.r, dist)/10. * amount * normalize(diff); st +=p ow(distort.b, dist)/10. * amount * normalize(diff); } else if(0==4 ) { vec2 diff=s t - pos; float radius=l ength(diff); segment=f
                ract(radius * divisions - uTime*0.01);distort=m ix(mix(first, second, segment*2.), mix(second, third, (segment - 0.5)/(1. - 0.5)), step(0.5, segment)); st -=p ow(distort.r, dist)/10. * amount * normalize(diff); st +=p ow(distort.b, dist)/10.
                * amount * normalize(diff); } else if(0==5 ) { vec2 diff=s t - pos; float angle=- PI/4.; vec2 rotatedDiff=v ec2( diff.x * cos(angle) - diff.y * sin(angle), diff.x * sin(angle) + diff.y * cos(angle) );float manhattanDist=a bs(rotatedDiff.x)
                + abs(rotatedDiff.y); segment=f ract(manhattanDist * divisions - uTime*0.01); distort=m ix(mix(first, second, segment*2.), mix(second, third, (segment - 0.5)/(1. - 0.5)), step(0.5, segment)); st -=p ow(distort.r, dist)/10. * amount * normalize(diff);
                st +=p ow(distort.b, dist)/10. * amount * normalize(diff); }st=r ot(0.11 * 2. * PI) * (st - pos) + pos; st=u nscaleAspect(st, aspectRatio); vec4 col=t exture(uTexture, st);if(0.00> 0.) { vec2 offset = vec2(pow(distort.r, dist), pow(distort.b, dist)) * vec2(0.1) * amount * 0.33; col.rgb = chromatic_abberation(st, offset * 0.00); } return col; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float aspectRatio
                = uResolution.x/uResolution.y;vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); vec2 pos = mPos; float mDist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.00)));if(mDist
                < distance(uv, mPos)) { vec4 color=t exture(uTexture, uv); if(0==1 ) { vec2 pos=m ix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor=t exture(uMaskTexture, vTextureCoord - pos); fragColor=c olor * (maskColor.a * maskColor.a); } else
                    { fragColor=c olor; }}vec4 col=b linds(uv, mDist); if(0==1 ) { vec2 pos=m ix(vec2(0), (uMousePos - 0.5), 0.00); vec4 maskColor=t exture(uMaskTexture, vTextureCoord - pos); fragColor=c ol * (maskColor.a * maskColor.a); } else { fragColor=c
                    ol; }} "],"compiledVertexShaders ":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void
                    main() { gl_Position=u PMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord=( uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; } "],"data ":{}}],"options ":{"name ":"Liquid Chroma ","fps ":60,"dpi ":2,"scale ":1},"version
                    ":"1.2.4 "}